#version 430 core
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D screen;
struct matStruct {
	int control;
    float posicion[4];
	float aceleracion[4];
	int adyacentes[8];
} newMaterial;

layout(binding = 3) buffer SSBO
{
	float DeltaT;
	float constMuelle;
	matStruct myarray[];
};

vec3 calcularMuelle(int idVecina, vec3 posicionParticula, float cteMuelle);

void main()
{
	float pesoParticula = 1.0;

	// SI SE PONE LA GRAVEDAD REAL CAE DEMASIADO RÁPIDO
	//vec3 gravedad = vec3(0, -9.80665, 0);
	vec3 gravedad = vec3(0, -0.001, 0);


	vec3 fuerza;

	// Ctes muelles (A*E/L, A = sección cilindro, E = módulo de elasticidad, L = longitud del muelle), LAS CTES ESTÁN INVENTADAS
	float cteMuelleHorizontal = 0.0001;
	float cteMuelleVertical = 0.0001;
	float cteMuelleDiagonal = 0.00001;
	float cteMuelleBending = 0.000001;

	// Gravedad
	fuerza = gravedad * pesoParticula;

	//ID WORKGROUP ES uvec3 gl_WorkGroupID 
	// Calculo del id de la particula dependiendo del workgroup (SE DEBE CAMBIAR PARA CÁLCULO SI SE CAMBIA EL TAMAÑO DE TELA)
	uint idParticula = 10 * gl_WorkGroupID.y + gl_WorkGroupID.x;
	matStruct particula = myarray[idParticula];
	// Cambiar a vec3 para facilitar cálculos
	vec3 posicionParticula = vec3(particula.posicion[0],particula.posicion[1],particula.posicion[2]);

	// Vecina 1 HORIZONTAL
	int idVecina = particula.adyacentes[1];
	if(idVecina!=-1){
		fuerza += calcularMuelle(idVecina,posicionParticula,cteMuelleHorizontal);
	}
	// Vecina 6 HORIZONTAL
	idVecina = particula.adyacentes[6];
	if(idVecina!=-1){
		fuerza += calcularMuelle(idVecina,posicionParticula,cteMuelleHorizontal);
	}
	// Vecina 3 VERTICAL 
	idVecina = particula.adyacentes[3];
	if(idVecina!=-1){
		fuerza += calcularMuelle(idVecina,posicionParticula,cteMuelleVertical);
	}
	// Vecina 4 VERTICAL 
	idVecina = particula.adyacentes[4];
	if(idVecina!=-1){
		fuerza += calcularMuelle(idVecina,posicionParticula,cteMuelleVertical);
	}
	// Vecina 0 DIAGONAL 
	idVecina = particula.adyacentes[0];
	if(idVecina!=-1){
		fuerza += calcularMuelle(idVecina,posicionParticula,cteMuelleDiagonal);
	}
	// Vecina 2 DIAGONAL 
	idVecina = particula.adyacentes[2];
	if(idVecina!=-1){
		fuerza += calcularMuelle(idVecina,posicionParticula,cteMuelleDiagonal);
	}
	// Vecina 5 DIAGONAL 
	idVecina = particula.adyacentes[5];
	if(idVecina!=-1){
		fuerza += calcularMuelle(idVecina,posicionParticula,cteMuelleDiagonal);
	}
	// Vecina 7 DIAGONAL 
	idVecina = particula.adyacentes[7];
	if(idVecina!=-1){
		fuerza += calcularMuelle(idVecina,posicionParticula,cteMuelleDiagonal);
	}

	// Intento cálculo Bending
	// Vecina 1 HORIZONTAL
	idVecina = particula.adyacentes[1];
	int idBending;
	if(idVecina!=-1){
		idBending = myarray[idVecina].adyacentes[1]; 
		if(idBending!=-1){
			fuerza += calcularMuelle(idBending,posicionParticula,cteMuelleBending);
		}
	}
	// Vecina 6 HORIZONTAL
	idVecina = particula.adyacentes[6];
	if(idVecina!=-1){
		idBending = myarray[idVecina].adyacentes[6]; 
		if(idBending!=-1){
			fuerza += calcularMuelle(idBending,posicionParticula,cteMuelleBending);
		}
	}
	// Vecina 3 VERTICAL 
	idVecina = particula.adyacentes[3];
	if(idVecina!=-1){
		idBending = myarray[idVecina].adyacentes[3]; 
		if(idBending!=-1){
			fuerza += calcularMuelle(idBending,posicionParticula,cteMuelleBending);
		}
	}
	// Vecina 4 VERTICAL 
	idVecina = particula.adyacentes[4];
	if(idVecina!=-1){
		idBending = myarray[idVecina].adyacentes[4]; 
		if(idBending!=-1){
			fuerza += calcularMuelle(idBending,posicionParticula,cteMuelleBending);
		}
	}

	// Cambiar posición
	// SE DEBE SABER EL DELTAT ENTRE CÁLCULOS, AHORA ESTÁ INVENTADO
	//float DeltaT = 1.0;
	vec3 aceleracion =  fuerza / pesoParticula;

	// Donde uso particula.aceleracion[0] deberia ser myarray[1].velocidad[0] (SE TIENE QUE CAMBIAR NOMBRE)
	float nuevaPosicionX = particula.posicion[0] + particula.aceleracion[0] * DeltaT + 0.5 * aceleracion[0] * DeltaT * DeltaT;
	float nuevaPosicionY = particula.posicion[1] + particula.aceleracion[1] * DeltaT + 0.5 * aceleracion[1] * DeltaT * DeltaT;
	float nuevaPosicionZ = particula.posicion[2] + particula.aceleracion[2] * DeltaT + 0.5 * aceleracion[2] * DeltaT * DeltaT;

	// FAKEAR OBJETO COLISION
	float planoColision[4] = {1.0,-1.0,5.0,-1.0};

	if(nuevaPosicionX >= planoColision[0] && nuevaPosicionX <= planoColision[2] && nuevaPosicionY > planoColision[1]){
		particula.posicion[0] = nuevaPosicionX;
		particula.posicion[1] = nuevaPosicionY;
	}

	//particula.posicion[0] = nuevaPosicionX;
	//particula.posicion[1] = nuevaPosicionY;
	particula.posicion[2] = nuevaPosicionZ;

	myarray[idParticula] = particula;





















	//vec4 pixel = vec4(0.075, 0.133, 0.173, 1.0);
	//ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
	
	//ivec2 dims = imageSize(screen);
	//float x = -(float(pixel_coords.x * 2 - dims.x) / dims.x); // transforms to [-1.0, 1.0]
	//float y = -(float(pixel_coords.y * 2 - dims.y) / dims.y); // transforms to [-1.0, 1.0]
	//float fov = 90.0;
	//vec3 cam_o = vec3(0.0, 0.0, -tan(fov / 2.0));
	//vec3 ray_o = vec3(x, y, 0.0);
	//vec3 ray_d = normalize(ray_o - cam_o);
	//vec3 sphere_c = vec3(0.0, 0.0, -5.0);
	//float sphere_r = 1.0;
	//vec3 o_c = ray_o - sphere_c;
	//float b = dot(ray_d, o_c);
	//float c = dot(o_c, o_c) - sphere_r * sphere_r;
	//float intersectionState = b * b - c;
	//vec3 intersection = ray_o + ray_d * (-b + sqrt(b * b - c));
	//if (intersectionState >= 0.0)
	//{
		//pixel = vec4((normalize(intersection - sphere_c) + 1.0) / 2.0, 1.0);
	//}
	//imageStore(screen, pixel_coords, pixel);

	//old_posicion[gl_GlobalInvocationID.x] = posicion[gl_GlobalInvocationID.x];
	//float time = 0.0f;
	
	//time += tiempo;
	//vec4 pos = posicion[gl_GlobalInvocationID.x];
	//posicion[gl_GlobalInvocation.x] = posicion[gl_GlobalInvocation.x] * 2 - old_posicion[gl_GlobalInvocationID.x] + aceleracion[gl_GlobalInvocationID.x] * time * time;
	//old_posicion[gl_GlobalInvocationID.x] = pos;
}

// Función que calcula la fuerza de un muelle
vec3 calcularMuelle(int idVecina, vec3 posicionParticula, float cteMuelle){
	
	vec3 posicionVecina = vec3(myarray[idVecina].posicion[0],myarray[idVecina].posicion[1],myarray[idVecina].posicion[2]);

		
	return -cteMuelle * (posicionParticula - posicionVecina);
}

